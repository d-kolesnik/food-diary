<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Food Diary</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #f9f9f9;
    }
    h1 {
      text-align: center;
    }
    form {
      margin-bottom: 20px;
      background: #fff;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    label {
      display: block;
      margin-top: 10px;
    }
    input, textarea, button, select {
      width: 100%;
      padding: 8px;
      margin-top: 5px;
      border: 1px solid #ccc;
      border-radius: 5px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      background: #fff;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    th, td {
      padding: 10px;
      border: 1px solid #ddd;
      text-align: left;
      vertical-align: middle;
    }
    th {
      background: #eee;
    }
    .btn-export {
      margin-top: 20px;
      padding: 10px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    .btn-export:hover {
      background: #45a049;
    }
    img.photo-thumb {
      max-width: 50px;
      max-height: 50px;
      display: block;
      cursor: pointer;
    }
    /* Modal / lightbox styles */
    .img-modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.8);
      z-index: 1000;
    }
    /* show when opened */
    .img-modal.open {
      display: flex;
    }
    .img-modal-content {
      position: relative;
      max-width: 90vw;
      max-height: 90vh;
      overflow: hidden;
      background: transparent;
      border-radius: 8px;
    }
    .img-modal img {
      display: block;
      user-select: none;
      -webkit-user-drag: none;
      transform-origin: center center;
      cursor: grab;
      will-change: transform;
      /* ensure image fits inside modal content so scale/translate are visible */
      max-width: 100%;
      max-height: 100%;
    }
    .img-modal .controls {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 8px;
    }
    .img-modal .controls button {
      padding: 6px 8px;
      background: rgba(255,255,255,0.9);
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    /* Mood layout tweaks */
    .mood-summary { cursor:pointer; font-weight: normal; margin-bottom: 8px; }
    .mood-cat { font-weight: normal; margin-bottom: 6px; }
  .mood-grid { display:grid; grid-template-columns: 1fr auto; row-gap:4px; column-gap:12px; }
  .mood-item { display: contents; }
  .mood-label { grid-column: 1; align-self: center; }
  .mood-checkbox { grid-column: 2; justify-self: end; align-self: center; }
  .mood-item input { margin:0; }
  </style>
</head>
<body>
  <h1>üçé My Food Diary</h1>

  <form id="foodForm">
    <label>Date:
      <input type="date" id="date" required />
    </label>
    <label>Time:
      <input type="time" id="time" required />
    </label>
    <details style="margin-top:14px;">
      <summary class="mood-summary">Mood</summary>
      <fieldset style="border:1px solid #eee;padding:10px;border-radius:6px;">
      <div style="display:flex;gap:24px;flex-wrap:wrap;">
        <div>
          <div class="mood-cat">üåßÔ∏è Negative / distress</div>
          <div class="mood-grid">
            <div class="mood-label">Stressed</div>
            <div class="mood-checkbox"><input type="checkbox" name="mood" value="Stressed"></div>
            <div class="mood-label">Anxious / worried</div>
            <div class="mood-checkbox"><input type="checkbox" name="mood" value="Anxious / worried"></div>
            <div class="mood-label">Angry / frustrated</div>
            <div class="mood-checkbox"><input type="checkbox" name="mood" value="Angry / frustrated"></div>
            <div class="mood-label">Sad / down</div>
            <div class="mood-checkbox"><input type="checkbox" name="mood" value="Sad / down"></div>
            <div class="mood-label">Lonely</div>
            <div class="mood-checkbox"><input type="checkbox" name="mood" value="Lonely"></div>
            <div class="mood-label">Guilty / ashamed</div>
            <div class="mood-checkbox"><input type="checkbox" name="mood" value="Guilty / ashamed"></div>
            <div class="mood-label">Overwhelmed</div>
            <div class="mood-checkbox"><input type="checkbox" name="mood" value="Overwhelmed"></div>
          </div>
        </div>
        <div>
          <div class="mood-cat">üòê Neutral / low-energy</div>
          <div class="mood-grid">
            <div class="mood-label">Tired / fatigued</div>
            <div class="mood-checkbox"><input type="checkbox" name="mood" value="Tired / fatigued"></div>
            <div class="mood-label">Bored</div>
            <div class="mood-checkbox"><input type="checkbox" name="mood" value="Bored"></div>
            <div class="mood-label">Numb / indifferent</div>
            <div class="mood-checkbox"><input type="checkbox" name="mood" value="Numb / indifferent"></div>
          </div>
        </div>
        <div>
          <div class="mood-cat">üåû Positive</div>
          <div class="mood-grid">
            <div class="mood-label">Happy</div>
            <div class="mood-checkbox"><input type="checkbox" name="mood" value="Happy"></div>
            <div class="mood-label">Relaxed / calm</div>
            <div class="mood-checkbox"><input type="checkbox" name="mood" value="Relaxed / calm"></div>
            <div class="mood-label">Excited / enthusiastic</div>
            <div class="mood-checkbox"><input type="checkbox" name="mood" value="Excited / enthusiastic"></div>
            <div class="mood-label">Content / satisfied</div>
            <div class="mood-checkbox"><input type="checkbox" name="mood" value="Content / satisfied"></div>
            <div class="mood-label">Proud</div>
            <div class="mood-checkbox"><input type="checkbox" name="mood" value="Proud"></div>
          </div>
        </div>
      </div>
      <div style="margin-top:8px;display:flex;align-items:center;gap:6px;">
        <label style="margin:0;">Other:</label>
        <input type="text" id="moodOtherText" placeholder="Enter other mood" style="width:auto;display:inline-block;" />
      </div>
      </fieldset>
    </details>
    <fieldset style="margin-top:8px;border:1px solid #eee;padding:8px;border-radius:6px;">
      <legend style="padding:0 6px;">Where did I eat?</legend>
      <div style="display:flex;align-items:center;gap:12px;flex-wrap:wrap;">
        <label style="display:inline-flex;align-items:center;gap:6px;width:auto;"><input type="radio" name="locationChoice" value="Home"> Home</label>
        <label style="display:inline-flex;align-items:center;gap:6px;width:auto;"><input type="radio" name="locationChoice" value="Work"> Work</label>
        <label style="display:inline-flex;align-items:center;gap:6px;width:auto;"><input type="radio" name="locationChoice" value="Restaurant"> Restaurant</label>
        <label style="display:inline-flex;align-items:center;gap:6px;width:auto;"><input type="radio" name="locationChoice" value="Other"> Other</label>
        <input type="text" id="locationOther" placeholder="Enter other location" style="width:auto;display:none;margin-left:6px;" />
      </div>
    </fieldset>
    <label>Who was I with?
      <input type="text" id="company" placeholder="e.g. alone, with friends, with family" />
    </label>
    <label>How hungry was I before eating?
      <div style="display:flex;align-items:center;gap:8px;"><input type="range" id="hungerBefore" min="1" max="10" value="5"><span id="hungerBeforeVal">5</span></div>
    </label>
    <label>How mindful was I while eating?
      <div style="display:flex;align-items:center;gap:8px;"><input type="range" id="mindful" min="1" max="10" value="5"><span id="mindfulVal">5</span></div>
    </label>
    <label>How strong was the craving?
      <div style="display:flex;align-items:center;gap:8px;"><input type="range" id="craving" min="1" max="10" value="5"><span id="cravingVal">5</span></div>
    </label>
    <label>How full did I feel after eating?
      <div style="display:flex;align-items:center;gap:8px;"><input type="range" id="fullAfter" min="1" max="10" value="5"><span id="fullAfterVal">5</span></div>
    </label>
    <label>How did I feel after eating?
      <input type="text" id="afterFeelingText" placeholder="e.g. guilty, satisfied, regretful, content" />
    </label>
    <label>Do I have any physical symptoms?
      <input type="text" id="symptomsText" placeholder="e.g. bloating, stomach pain, nausea, heartburn" />
    </label>
    <label>Calories:
      <input type="number" id="calories" placeholder="e.g. 500" />
    </label>
    <label>Notes:
      <textarea id="notes" placeholder="e.g. someone brought a birthday cake to the office"></textarea>
    </label>
    <label>Photo:
      <input type="file" id="photo" accept="image/*" />
    </label>
    <div id="photoPreviewContainer" style="margin-top:8px;">
      <img id="photoPreview" src="" alt="Photo preview" style="max-width:120px;max-height:120px;display:none;border:1px solid #ddd;padding:4px;border-radius:4px;" />
    </div>
    <button type="submit">Save Entry</button>
  </form>

  <table id="foodTable">
    <thead>
      <tr>
        <th>Date</th>
        <th>Time</th>
        <th>Mood</th>
  <th>Where</th>
  <th>Who</th>
  <th>Hunger before</th>
  <th>Mindful</th>
  <th>Craving</th>
  <th>Full after</th>
  <th>After feeling</th>
  <th>Symptoms</th>
        <th>Calories</th>
        <th>Notes</th>
        <th>Photo</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <button class="btn-export" id="exportBtn">Export to Excel</button>

  <!-- Image modal / lightbox -->
  <div class="img-modal" id="imgModal" aria-hidden="true">
    <div class="img-modal-content" id="imgModalContent">
      <div class="controls">
        <button id="zoomInBtn" title="Zoom in">+</button>
        <button id="zoomOutBtn" title="Zoom out">‚àí</button>
        <button id="resetBtn" title="Reset">Reset</button>
        <button id="closeBtn" title="Close">‚úï</button>
      </div>
      <img id="modalImage" src="" alt="Food photo" />
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script>
  const form = document.getElementById('foodForm');
  const tableBody = document.querySelector('#foodTable tbody');
  const exportBtn = document.getElementById('exportBtn');
  const dateInput = document.getElementById('date');
  const timeInput = document.getElementById('time');
  const photoInput = document.getElementById('photo');

  // Modal elements
  const imgModal = document.getElementById('imgModal');
  const modalImage = document.getElementById('modalImage');
  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const resetBtn = document.getElementById('resetBtn');
  const closeBtn = document.getElementById('closeBtn');

  const now = new Date();
  dateInput.valueAsDate = now;
  timeInput.value = now.toTimeString().slice(0,5);

  let entries = JSON.parse(localStorage.getItem('foodEntries')) || [];
  let editIndex = null;
  // photo being edited/previewed (data URL)
  let editingPhoto = null;

  // State for modal image transform
  let scale = 1;
  let translateX = 0;
  let translateY = 0;
  let isPanning = false;
  let startX = 0;
  let startY = 0;

  renderTable();

  // update displayed values for sliders
  ['hungerBefore','mindful','craving','fullAfter'].forEach(id => {
    const el = document.getElementById(id);
    const valEl = document.getElementById(id + 'Val');
    if (el && valEl) {
      el.addEventListener('input', () => valEl.textContent = el.value);
    }
  });

  // Photo input preview and editing state
  const photoPreview = document.getElementById('photoPreview');
  photoInput.addEventListener('change', function() {
    const f = photoInput.files[0];
    if (!f) {
      // user cleared file input; keep existing editingPhoto until save/clear
      return;
    }
    processImageFile(f).then(dataUrl => {
      editingPhoto = dataUrl;
      if (photoPreview) {
        photoPreview.src = dataUrl;
        photoPreview.style.display = 'inline-block';
      }
    }).catch(err => {
      console.error('Preview processing failed', err);
      alert('Could not process selected photo for preview.');
    });
  });

  form.addEventListener('submit', function(e) {
    e.preventDefault();

    const file = photoInput.files[0];

    if (file) {
      // process image (resize/compress) to avoid localStorage quota issues on mobile
      processImageFile(file).then(dataUrl => {
        saveEntry(dataUrl);
      }).catch(err => {
        console.error('Image processing failed', err);
        alert('Could not process the photo. Try a smaller image or use a desktop to attach it.');
        // still try to save without photo
        saveEntry(null);
      });
    } else {
      // if editing an existing entry and no new file selected, keep the existing photo
      saveEntry(editingPhoto || null);
    }
  });

  // Read an image file and resize/compress it. Returns a Promise resolving to a data URL.
  function processImageFile(file, maxWidth = 1024, maxSizeBytes = 1024*700) {
    return new Promise((resolve, reject) => {
      try {
        const reader = new FileReader();
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.onload = function(e) {
          const img = new Image();
          img.onload = function() {
            // compute new size keeping aspect ratio
            let iw = img.width;
            let ih = img.height;
            let scale = Math.min(1, maxWidth / Math.max(iw, ih));
            let sw = Math.round(iw * scale);
            let sh = Math.round(ih * scale);
            const canvas = document.createElement('canvas');
            canvas.width = sw;
            canvas.height = sh;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, sw, sh);
            // try gradually reducing quality until size below threshold
            let quality = 0.9;
            function tryExport() {
              const dataUrl = canvas.toDataURL('image/jpeg', quality);
              // estimate size from base64 length
              const size = Math.round((dataUrl.length - 'data:image/jpeg;base64,'.length) * 3/4);
              if (size <= maxSizeBytes || quality <= 0.4) {
                resolve(dataUrl);
              } else {
                quality -= 0.15;
                tryExport();
              }
            }
            tryExport();
          };
          img.onerror = () => reject(new Error('Invalid image'));
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      } catch (err) {
        reject(err);
      }
    });
  }

  function saveEntry(photoData) {
    const entry = {
      date: dateInput.value,
      time: timeInput.value,
      mood: getSelectedMoods(),
  location: document.getElementById('location').value,
  company: document.getElementById('company').value,
  hungerBefore: document.getElementById('hungerBefore').value,
  mindful: document.getElementById('mindful').value,
  craving: document.getElementById('craving').value,
  fullAfter: document.getElementById('fullAfter').value,
  afterFeeling: document.getElementById('afterFeelingText').value,
  symptoms: document.getElementById('symptomsText').value,
      calories: document.getElementById('calories').value,
      notes: document.getElementById('notes').value,
      photo: photoData
    };

    if (editIndex === null) {
      entries.push(entry);
    } else {
      entries[editIndex] = entry;
      editIndex = null;
    }

    try {
      localStorage.setItem('foodEntries', JSON.stringify(entries));
      renderTable();
    } catch (err) {
      console.warn('localStorage setItem failed, possibly quota exceeded', err);
      // try fallback: remove photo and save
      if (entry.photo) {
        if (confirm('Saving the photo failed (likely too large). Save the entry without the photo?')) {
          entry.photo = null;
          if (editIndex === null) {
            entries[entries.length-1] = entry; // replace last pushed
          } else {
            entries[editIndex] = entry;
          }
          try {
            localStorage.setItem('foodEntries', JSON.stringify(entries));
            renderTable();
            return;
          } catch (err2) {
            console.error('Fallback save failed', err2);
            alert('Saving failed. Please clear some space in your browser or use smaller photos.');
            return;
          }
        } else {
          alert('Entry not saved. Try a smaller photo or save without a photo.');
          return;
        }
      } else {
        alert('Saving failed. Please clear some space in your browser.');
      }
    }

    form.reset();
    dateInput.valueAsDate = new Date();
    timeInput.value = new Date().toTimeString().slice(0,5);
    // clear editing state and preview
    editingPhoto = null;
    const photoPreview = document.getElementById('photoPreview');
    if (photoPreview) { photoPreview.src = ''; photoPreview.style.display = 'none'; }
  }

  function renderTable() {
    tableBody.innerHTML = '';
    entries.forEach((entry, index) => {
      const row = document.createElement('tr');
      row.innerHTML = `
        <td>${entry.date}</td>
        <td>${entry.time}</td>
        <td>${Array.isArray(entry.mood) ? entry.mood.join(', ') : (entry.mood || '')}</td>
  <td>${entry.location || ''}</td>
  <td>${entry.company || ''}</td>
  <td>${entry.hungerBefore || ''}</td>
  <td>${entry.mindful || ''}</td>
  <td>${entry.craving || ''}</td>
  <td>${entry.fullAfter || ''}</td>
  <td>${entry.afterFeeling || ''}</td>
  <td>${entry.symptoms || ''}</td>
        <td>${entry.calories}</td>
        <td>${entry.notes}</td>
        <td>${entry.photo ? `<img src="${entry.photo}" class="photo-thumb" data-index="${index}" />` : ''}</td>
        <td>
          <button onclick="editEntry(${index})">Edit</button>
          <button onclick="deleteEntry(${index})">Delete</button>
        </td>
      `;
      tableBody.appendChild(row);
      // attach click/keyboard handlers to thumbnail (use JS listeners to avoid issues with inline handlers)
      const imgEl = row.querySelector('.photo-thumb');
      if (imgEl) {
        imgEl.style.pointerEvents = 'auto';
        imgEl.tabIndex = 0;
        imgEl.addEventListener('click', function() { openImageModal(index); });
        imgEl.addEventListener('keydown', function(e) { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); openImageModal(index); } });
      }
    });
  }

  // Delegated handlers: robust fallback if individual listeners fail for any reason
  tableBody.addEventListener('click', function(e) {
    const img = e.target.closest('.photo-thumb');
    if (!img) return;
    const idx = img.dataset.index;
    if (idx == null) return;
    openImageModal(Number(idx));
  });
  tableBody.addEventListener('keydown', function(e) {
    const img = e.target.closest('.photo-thumb');
    if (!img) return;
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      const idx = img.dataset.index;
      if (idx == null) return;
      openImageModal(Number(idx));
    }
  });

  // Expose edit/delete to global scope (used by inline onclicks)
  window.editEntry = function(index) {
    const entry = entries[index];
    dateInput.value = entry.date;
    timeInput.value = entry.time;
    populateMoodControls(entry.mood);
  document.getElementById('location').value = entry.location || '';
  document.getElementById('company').value = entry.company || '';
    document.getElementById('hungerBefore').value = entry.hungerBefore || 5;
    document.getElementById('mindful').value = entry.mindful || 5;
    document.getElementById('craving').value = entry.craving || 5;
    document.getElementById('fullAfter').value = entry.fullAfter || 5;
    document.getElementById('afterFeelingText').value = entry.afterFeeling || '';
    document.getElementById('symptomsText').value = entry.symptoms || '';
    // update slider labels
    document.getElementById('hungerBeforeVal').textContent = document.getElementById('hungerBefore').value;
    document.getElementById('mindfulVal').textContent = document.getElementById('mindful').value;
    document.getElementById('cravingVal').textContent = document.getElementById('craving').value;
    document.getElementById('fullAfterVal').textContent = document.getElementById('fullAfter').value;
    document.getElementById('calories').value = entry.calories;
    document.getElementById('notes').value = entry.notes;
    editIndex = index;
    // set editing photo preview (preserve existing photo until replaced)
    editingPhoto = entry.photo || null;
    if (editingPhoto && photoPreview) {
      photoPreview.src = editingPhoto;
      photoPreview.style.display = 'inline-block';
    } else if (photoPreview) {
      photoPreview.src = '';
      photoPreview.style.display = 'none';
    }
    // clear any selected file in the input so we don't accidentally read a stale FileList
    if (photoInput) photoInput.value = '';
  };

  window.deleteEntry = function(index) {
    if (confirm("Are you sure you want to delete this entry?")) {
      entries.splice(index, 1);
      localStorage.setItem('foodEntries', JSON.stringify(entries));
      renderTable();
    }
  };

  exportBtn.addEventListener('click', function() {
    const exportEntries = entries.map(entry => {
      const e = { ...entry };
      if (e.photo) e.photo = '[Image]';
      return e;
    });
    const worksheet = XLSX.utils.json_to_sheet(exportEntries);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Food Diary');
    XLSX.writeFile(workbook, 'food-diary.xlsx');
  });

  // Mood helpers
  function getSelectedMoods() {
    const checked = Array.from(document.querySelectorAll('input[type=checkbox][name="mood"]:checked'))
      .map(cb => cb.value);
    const otherText = document.getElementById('moodOtherText').value.trim();
    if (otherText) checked.push(otherText);
    return checked;
  }

  function populateMoodControls(moodValue) {
    // Clear all
    document.querySelectorAll('input[type=checkbox][name="mood"]').forEach(cb => cb.checked = false);
    document.getElementById('moodOtherText').value = '';

    if (!moodValue) return;
    const moods = Array.isArray(moodValue) ? moodValue : [moodValue];
    moods.forEach(m => {
      // try to find exact match among checkboxes
      const match = Array.from(document.querySelectorAll('input[type=checkbox][name="mood"]'))
        .find(cb => cb.value === m);
      if (match) {
        match.checked = true;
      } else {
        // fill other text
        const otherText = document.getElementById('moodOtherText');
        otherText.value = m;
      }
    });
  }


  // ----- Modal functions -----
  function openImageModal(index) {
    const entry = entries[index];
    if (!entry || !entry.photo) return;
    console.debug('openImageModal called for index', index);
    modalImage.src = entry.photo;
    resetTransform();
    imgModal.classList.add('open');
    imgModal.setAttribute('aria-hidden', 'false');
    modalImage.style.cursor = 'grab';
    // Focus to capture keyboard events
    document.addEventListener('keydown', onKeyDown);
  }
  window.openImageModal = openImageModal; // allow inline call

  function closeImageModal() {
    imgModal.classList.remove('open');
    imgModal.setAttribute('aria-hidden', 'true');
    document.removeEventListener('keydown', onKeyDown);
  }

  function resetTransform() {
    scale = 1;
    translateX = 0;
    translateY = 0;
    applyTransform();
  }

  function applyTransform() {
    modalImage.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
  }

  function changeScale(delta, centerX, centerY) {
    console.debug('changeScale', { delta, scaleBefore: scale, centerX, centerY });
    const prevScale = scale;
    scale = Math.max(0.5, Math.min(5, scale + delta));
    // Adjust translate to zoom toward pointer
    if (centerX != null && centerY != null) {
      const rect = modalImage.getBoundingClientRect();
      const dx = centerX - rect.left;
      const dy = centerY - rect.top;
      // compute new translation so that point under cursor stays roughly fixed
      translateX -= (dx / prevScale) * (scale - prevScale);
      translateY -= (dy / prevScale) * (scale - prevScale);
    }
    // only apply transform if modalImage is in the DOM and has naturalWidth (loaded)
    if (modalImage && modalImage.complete && modalImage.naturalWidth) {
      applyTransform();
    } else {
      console.warn('applyTransform skipped: image not loaded/available');
    }
  }

  // Mouse wheel to zoom
  imgModal.addEventListener('wheel', function(e) {
    if (!imgModal.classList.contains('open')) return;
    console.debug('imgModal wheel event', { deltaY: e.deltaY });
    e.preventDefault();
    const delta = e.deltaY > 0 ? -0.1 : 0.1;
    changeScale(delta, e.clientX, e.clientY);
  }, { passive: false });

  // Buttons
  if (zoomInBtn) zoomInBtn.addEventListener('click', () => changeScale(0.2)); else console.warn('zoomInBtn missing');
  if (zoomOutBtn) zoomOutBtn.addEventListener('click', () => changeScale(-0.2)); else console.warn('zoomOutBtn missing');
  resetBtn.addEventListener('click', resetTransform);
  closeBtn.addEventListener('click', closeImageModal);

  // Drag to pan
  modalImage.addEventListener('mousedown', function(e) {
    if (!imgModal.classList.contains('open')) return;
    isPanning = true;
    startX = e.clientX - translateX;
    startY = e.clientY - translateY;
    modalImage.style.cursor = 'grabbing';
    e.preventDefault();
  });
  window.addEventListener('mousemove', function(e) {
    if (!isPanning) return;
    translateX = e.clientX - startX;
    translateY = e.clientY - startY;
    applyTransform();
  });
  window.addEventListener('mouseup', function() {
    if (isPanning) {
      isPanning = false;
      modalImage.style.cursor = 'grab';
    }
  });

  // Touch events for mobile
  modalImage.addEventListener('touchstart', function(e) {
    if (e.touches.length === 1) {
      const t = e.touches[0];
      isPanning = true;
      startX = t.clientX - translateX;
      startY = t.clientY - translateY;
    }
  }, { passive: true });
  modalImage.addEventListener('touchmove', function(e) {
    if (!isPanning || e.touches.length !== 1) return;
    const t = e.touches[0];
    translateX = t.clientX - startX;
    translateY = t.clientY - startY;
    applyTransform();
  }, { passive: true });
  modalImage.addEventListener('touchend', function() { isPanning = false; });

  // Close modal when clicking backdrop
  imgModal.addEventListener('click', function(e) {
    if (e.target === imgModal) closeImageModal();
  });

  function onKeyDown(e) {
    if (e.key === 'Escape') closeImageModal();
    if (e.key === '+') changeScale(0.2);
    if (e.key === '-') changeScale(-0.2);
    if (e.key === '0') resetTransform();
  }
</script>

</body>
</html>
